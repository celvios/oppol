// Advanced Recovery using permissionless.js + Pimlico
// 0xd0A... is an ERC-4337 Smart Account, owned by the Privy Embedded EOA
require('dotenv').config({ path: '../../.env' });
const { createPublicClient, createWalletClient, http, encodeFunctionData } = require('viem');
const { bsc } = require('viem/chains');
const { privateKeyToAccount } = require('viem/accounts');
const { createSmartAccountClient } = require('permissionless');
const { createPimlicoClient } = require('permissionless/clients/pimlico');
const { toSimpleSmartAccount } = require('permissionless/accounts');
const { entryPoint07Address } = require('viem/account-abstraction');
const { Pool } = require('pg');
const crypto = require('crypto');
const { ethers } = require('ethers');

const TARGET_WALLET = '0x42501490f7c291b4B28110900c9Bd81f3B35B849';
const SMART_ACCOUNT = '0xd0A115Ea64B59F951B70276fCb65b4946465e3a9';
const USDT_ADDR = '0x55d398326f99059fF775485246999027B3197955';

function decrypt(enc) {
    const key = Buffer.from(process.env.ENCRYPTION_KEY, 'hex');
    const [ivH, data] = enc.split(':');
    const dc = crypto.createDecipheriv('aes-256-cbc', key, Buffer.from(ivH, 'hex'));
    return dc.update(data, 'hex', 'utf8') + dc.final('utf8');
}

async function main() {
    const rpcUrl = 'https://bsc-dataseed.binance.org/';
    const provider = new ethers.JsonRpcProvider(rpcUrl);

    // Check balance
    const usdt = new ethers.Contract(USDT_ADDR, ['function balanceOf(address) view returns(uint256)'], provider);
    const bal = await usdt.balanceOf(SMART_ACCOUNT);
    console.log(`Smart Account USDT: ${ethers.formatUnits(bal, 18)}`);

    if (bal === 0n) return console.log('❌ No USDT to recover');

    // 1. We know the Privy EOA is in the DB (it's the 'custodial wallet' we found earlier)
    // Actually we found it by the SMART_ACCOUNT address earlier? Wait, the DB lookup failed earlier for 0xd0A...
    // Let me check if the EOA for the user is in the DB
    const pool = new Pool({ connectionString: process.env.DATABASE_URL, ssl: { rejectUnauthorized: false } });
    const r = await pool.query('SELECT public_address, encrypted_private_key FROM wallets WHERE user_id = (SELECT id FROM users WHERE privy_user_id = $1)', ['did:privy:1cb3e6daef32d169ac81ebae']);

    if (r.rows.length === 0) {
        console.log('❌ No EOA key found in DB for that user.');
        pool.end();
        return;
    }

    const { public_address, encrypted_private_key } = r.rows[0];
    console.log(`✅ Found EOA Owner in DB: ${public_address}`);

    const privKey = decrypt(encrypted_private_key);
    const ownerAccount = privateKeyToAccount(privKey);

    const publicClient = createPublicClient({ chain: bsc, transport: http(rpcUrl) });
    const pimlicoUrl = `https://api.pimlico.io/v2/56/rpc?apikey=${process.env.NEXT_PUBLIC_PIMLICO_API_KEY}`;
    const pimlicoClient = createPimlicoClient({ transport: http(pimlicoUrl), entryPoint: { address: entryPoint07Address, version: "0.7" } });

    console.log('\n--- 2. Building Smart Account Client ---');
    const simpleAccount = await toSimpleSmartAccount({
        client: publicClient,
        owner: ownerAccount,
        entryPoint: { address: entryPoint07Address, version: "0.7" }
    });

    console.log(`Calculated Smart Account Address: ${simpleAccount.address}`);
    if (simpleAccount.address.toLowerCase() !== SMART_ACCOUNT.toLowerCase()) {
        console.log('⚠️ Warning: Calculated address does not match 0xd0A...');
        // Let's try to override or force it if possible, but usually SimpleSmartAccount is deterministic
    }

    const smartAccountClient = createSmartAccountClient({
        account: simpleAccount,
        chain: bsc,
        bundlerTransport: http(pimlicoUrl),
        paymaster: pimlicoClient,
        userOperation: { estimateFeesPerGas: async () => (await pimlicoClient.getUserOperationGasPrice()).fast }
    });

    console.log(`\n--- 3. Submitting USDT Transfer UserOp ---`);
    const callData = encodeFunctionData({
        abi: parseAbi(['function transfer(address to, uint256 value)']),
        functionName: 'transfer',
        args: [TARGET_WALLET, bal]
    });

    try {
        const userOpHash = await smartAccountClient.sendUserOperation({
            calls: [{ to: USDT_ADDR, value: 0n, data: callData }]
        });
        console.log(`UserOp Submitted: ${userOpHash}`);

        console.log('Waiting for receipt...');
        const receipt = await pimlicoClient.waitForUserOperationReceipt({ hash: userOpHash });
        console.log(`\n✅ TRANSFER SUCCESS! Tx Hash: https://bscscan.com/tx/${receipt.receipt.transactionHash}`);
    } catch (e) {
        console.log('\n❌ Failed: ' + e.message);
    }

    pool.end();
}

main().catch(console.error);
